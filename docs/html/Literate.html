<!doctype html>
<html lang="en">
<head>
<title>A grammar to parse a file into Pod and Code sections.</title>
<meta charset="UTF-8" />

<link href="/asset_files/images/favicon.ico" rel="icon" type="image/x-icon"/>
<link rel="stylesheet" type="text/css" href="asset_files/css/rakudoc-extra.css" />
<link rel="stylesheet" type="text/css" href="asset_files/css/rakudoc-styling.css" />
<link rel="stylesheet" type="text/css" href="asset_files/css/font-awesome.min.css" />

</head>
	<body class="pod">
<header>
<img id="Camelia_bug" src="/asset_files/images/Camelia.svg"><h1 class="title">A grammar to parse a file into Pod and Code sections.</h1></header><div class="pod-content"><nav><div id="_TOC"><table>
<caption>Table of Contents</caption>
<tr class="toc-level-1"><td class="toc-text"><a href="#INTRODUCTION">INTRODUCTION</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#Convenient_tokens">Convenient tokens</a></td></tr>
 <tr class="toc-level-1"><td class="toc-text"><a href="#The_Grammar">The Grammar</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#The_Pod6_delimiters">The Pod6 delimiters</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#The_begin-pod_token">The begin-pod token</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#The_end-pod_token">The end-pod token</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#Replacing_Pod6_sections_with_blank_lines">Replacing Pod6 sections with blank lines</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#The_Pod_token">The Pod token</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#The_Code_tokens">The Code tokens</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#Woven_sections">Woven sections</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#Non-woven_sections">Non-woven sections</a></td></tr>
 <tr class="toc-level-4"><td class="toc-text"><a href="#One_line_of_code">One line of code</a></td></tr>
 <tr class="toc-level-4"><td class="toc-text"><a href="#Delimited_blocks_of_code">Delimited blocks of code</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#The_plain-line_token">The plain-line token</a></td></tr>
 <tr class="toc-level-1"><td class="toc-text"><a href="#The_Tangle_subroutine">The Tangle subroutine</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#Clean_the_source">Clean the source</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#Remove_unnecessary_blank_lines">Remove unnecessary blank lines</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#The_interesting_stuff">The interesting stuff</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#Replace_Pod6_sections_with_blank_lines">Replace Pod6 sections with blank lines</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#Remove_the_no-weave_delimiters">Remove the no-weave delimiters</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#remove_blank_lines_at_the_end">remove blank lines at the end</a></td></tr>
 <tr class="toc-level-1"><td class="toc-text"><a href="#The_Weave_subroutine">The Weave subroutine</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#The_parameters_of_Weave">The parameters of Weave</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#$input-file">$input-file</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#$format">$format</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#$line-numbers">$line-numbers</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#Remove_blank_lines_at_the_begining_and_end_of_the_code">Remove blank lines at the begining and end of the code</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#Interesting_stuff">Interesting stuff</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#remove_blank_lines_at_the_end">remove blank lines at the end</a></td></tr>
 <tr class="toc-level-1"><td class="toc-text"><a href="#NAME">NAME</a></td></tr>
 <tr class="toc-level-1"><td class="toc-text"><a href="#VERSION">VERSION</a></td></tr>
 <tr class="toc-level-1"><td class="toc-text"><a href="#SYNOPSIS">SYNOPSIS</a></td></tr>
 <tr class="toc-level-1"><td class="toc-text"><a href="#DESCRIPTION">DESCRIPTION</a></td></tr>
 <tr class="toc-level-1"><td class="toc-text"><a href="#BUGS_AND_LIMITATIONS">BUGS AND LIMITATIONS</a></td></tr>
 <tr class="toc-level-1"><td class="toc-text"><a href="#AUTHOR">AUTHOR</a></td></tr>
 <tr class="toc-level-1"><td class="toc-text"><a href="#LICENSE_AND_COPYRIGHT">LICENSE AND COPYRIGHT</a></td></tr>
</table></div>
</nav><div id=""></div><div class="pod-body">
<section name="___top"><pre class="pod-block-code">    1| #! /usr/bin/env raku
    2| 
    3| # Get the Pod vs. Code structure of a Raku/Pod6 file.
    4| # Â© 2023 Shimon Bollinger. All rights reserved.
    5| # Last modified: Mon 11 Sep 2023 01:14:39 PM EDT
    6| # Version 0.0.1
    7| 
</pre></section>
<section name="___top">
<h1 id="INTRODUCTION"><a href="#A_grammar_to_parse_a_file_into_Pod_and_Code_sections." class="u" title="go to top of document">INTRODUCTION</a></h1>
<p>I want to create a semi-literate Raku source file with the extension <code>.sl</code>. Then, I will <em>weave</em> it to generate a readable file in formats like Markdown, PDF, HTML, and more. Additionally, I will <em>tangle</em> it to create source code without any Pod6.</p>
<h2 id="Convenient_tokens"><a href="#A_grammar_to_parse_a_file_into_Pod_and_Code_sections." class="u" title="go to top of document">Convenient tokens</a></h2>
<p>Let's create some tokens for convenience.</p></section>
<section name="pod"><pre class="pod-block-code">    8|     #TODO put these in a Role
    9|     my token hws            {    &lt;!ww&gt;\h*       } # Horizontal White Space
   10|     my token leading-ws     { ^^ &lt;hws&gt;          } # Whitespace at start of line
   11|     my token optional-chars {    \N*?           }
   12|     my token opening-quote { &lt;
   13|                               :Ps +
   14|                               :Pi +
   15|                               [\' \&quot; \\]
   16|                              &gt;
   17|     } # end of my token opening-quote
</pre></section>
<section name="pod"><p>To do this, I need to divide the file into <code>Pod</code> and <code>Code</code> sections by parsing it. For this purpose, I will create a dedicated Grammar.</p>
<h1 id="The_Grammar"><a href="#A_grammar_to_parse_a_file_into_Pod_and_Code_sections." class="u" title="go to top of document">The Grammar</a></h1>
</section>
<section name="pod"><pre class="pod-block-code">   18| #use Grammar::Tracer;
   19| grammar Semi::Literate is export {
</pre></section>
<section name="pod"><p>Our file will exclusively consist of <code>Pod</code> or <code>Code</code> sections, and nothing else. The <code>Code</code> sections are of two types, a) code that is woven into the documentation, and b) code that is not woven into the documentation. The <code>TOP</code> token clearly indicates this.</p></section>
<section name="pod"><pre class="pod-block-code">   20|     token TOP {
   21|         [
   22|           || &lt;pod&gt;
   23|           || &lt;non-woven-code&gt;
   24|           || &lt;woven-code&gt;
   25|         ]*
   26|     } # end of token TOP
</pre></section>
<section name="pod">
<h2 id="The_Pod6_delimiters"><a href="#A_grammar_to_parse_a_file_into_Pod_and_Code_sections." class="u" title="go to top of document">The Pod6 delimiters</a></h2>
<p>According to the <a href="https://docs.raku.org/language/pod">documentation</a>,</p><dl>
<dt>Every Pod6 document has to begin with =begin pod and end with =end pod.</dt><dd></dd>
</dl><p>So let's define those tokens.</p>
<h3 id="The_begin-pod_token"><a href="#A_grammar_to_parse_a_file_into_Pod_and_Code_sections." class="u" title="go to top of document">The <code>begin-pod</code> token</a></h3>
</section>
<section name="pod"><pre class="pod-block-code">   27|     token begin-pod {
   28|         ^^ &lt;hws&gt; '=' begin &lt;hws&gt; pod &lt;ws-till-EOL&gt;
   29|     } # end of token begin-pod
</pre></section>
<section name="pod">
<h3 id="The_end-pod_token"><a href="#A_grammar_to_parse_a_file_into_Pod_and_Code_sections." class="u" title="go to top of document">The <code>end-pod</code> token</a></h3>
<p>The <code>end-pod</code> token is much simpler.</p></section>
<section name="pod"><pre class="pod-block-code">   30|     token end-pod { ^^ &lt;hws&gt; '=' end &lt;hws&gt; pod &lt;ws-till-EOL&gt; }
</pre></section>
<section name="pod">
<h3 id="Replacing_Pod6_sections_with_blank_lines"><a href="#A_grammar_to_parse_a_file_into_Pod_and_Code_sections." class="u" title="go to top of document">Replacing Pod6 sections with blank lines</a></h3>
<p>Most programming applications do not focus on the structure of the executable file, which is not meant to be easily read by humans. Our tangle would replace all the Pod6 blocks with a single <code>\n</code>. That can clump code together that is easier read if there were one or more blank lines.</p><p>However, we can provide the option for users to specify the number of empty lines that should replace a <code>pod</code> block. To do this, simply add a Pod6 comment immediately after the <code>=begin pod</code> statement. The comment can say anything you like, but must end with a digit specifying the number of blank lines with which to replace the Pod6 section.</p></section>
<section name="pod"><pre class="pod-block-code">   31|     token blank-line-comment {
   32|         ^^ &lt;hws&gt;
   33|         '=' comment
   34|         \N*?
   35|         $&lt;num-blank-lines&gt; = (\d+)?
   36|         &lt;ws-till-EOL&gt;
   37|     } # end of token blank-line-comment
</pre></section>
<section name="pod">
<h2 id="The_Pod_token"><a href="#A_grammar_to_parse_a_file_into_Pod_and_Code_sections." class="u" title="go to top of document">The <code>Pod</code> token</a></h2>
<p>Within the delimiters, all lines are considered documentation. We will refer to these lines as <code>plain-lines</code>. Additionally, it is possible to have nested <code>Pod</code> sections. This allows for a hierarchical organization of documentation, allowing for more structured and detailed explanations.</p><p>It is also permissible for the block to be empty. Therefore, we will use the 'zero-or-more' quantifier on the lines of documentation, allowing for the possibility of having no lines in the block.</p></section>
<section name="pod"><pre class="pod-block-code">   38|     token pod {
   39|         &lt;begin-pod&gt;
   40|         &lt;blank-line-comment&gt;?
   41|             [&lt;pod&gt; | &lt;plain-line&gt;]*
   42|         &lt;end-pod&gt;
   43|     } # end of token pod
</pre></section>
<section name="pod">
<h2 id="The_Code_tokens"><a href="#A_grammar_to_parse_a_file_into_Pod_and_Code_sections." class="u" title="go to top of document">The <code>Code</code> tokens</a></h2>
<p>The <code>Code</code> sections are similarly easily defined. There are two types of <code>Code</code> sections, depending on whether they will appear in the woven code. See <a href="below.html">below</a> for why some code would not be included in the woven code.</p>
<h3 id="Woven_sections"><a href="#A_grammar_to_parse_a_file_into_Pod_and_Code_sections." class="u" title="go to top of document">Woven sections</a></h3>
<p>These sections are trivially defined. They are just one or more <code>plain-line</code>s.</p></section>
<section name="pod"><pre class="pod-block-code">   44|     token woven-code  {
   45|         [
   46|             || &lt;plain-line&gt;
   47|         ]+
   48|     } # end of token woven-code
</pre></section>
<section name="pod">
<h3 id="Non-woven_sections"><a href="#A_grammar_to_parse_a_file_into_Pod_and_Code_sections." class="u" title="go to top of document">Non-woven sections</a></h3>
<p>Sometimes there will be code you do not want woven into the document, such as boilerplate code like <code>use v6.d;</code>. You have two options to mark such code. By individual lines or by delimited blocks of code.</p></section>
<section name="pod"><pre class="pod-block-code">   49|     token non-woven-code {
   50|         [
   51|           || &lt;one-line-no-weave&gt;
   52|           || &lt;delimited-no-weave&gt;
   53|         ]+
   54|     } # end of token non-woven
</pre></section>
<section name="pod">
<h4 id="One_line_of_code"><a href="#A_grammar_to_parse_a_file_into_Pod_and_Code_sections." class="u" title="go to top of document">One line of code</a></h4>
<p>Simply append <code># begin-no-weave</code> at the end of the line!</p></section>
<section name="pod"><pre class="pod-block-code">   55|     token one-line-no-weave {
   56|         ^^ \N*?
   57|         '#' &lt;hws&gt; 'no-weave-this-line'
   58|         &lt;ws-till-EOL&gt;
   59|     } # end of token one-line-no-weave
</pre></section>
<section name="pod">
<h4 id="Delimited_blocks_of_code"><a href="#A_grammar_to_parse_a_file_into_Pod_and_Code_sections." class="u" title="go to top of document">Delimited blocks of code</a></h4>
<p>Simply add comments <code># begin-no-weave</code> and <code>#end-no-weave</code> before and after the code you want ignored in the formatted document.</p></section>
<section name="pod"><pre class="pod-block-code">   60|     token begin-no-weave {
   61|         ^^ &lt;hws&gt;                    # optional leading whitespace
   62|         '#' &lt;hws&gt; 'begin-no-weave'  # the delimiter itself (# begin-no-weave)
   63|         &lt;ws-till-EOL&gt;               # optional trailing whitespace or comment
   64|     } # end of token &lt;begin-no-weave&gt;
   65| 
   66|     token end-no-weave {
   67|         ^^ &lt;hws&gt;                    # optional leading whitespace
   68|         '#' &lt;hws&gt; 'end-no-weave'    # the delimiter itself (#end-no-weave)
   69|         &lt;ws-till-EOL&gt;               # optional trailing whitespace or comment
   70|     } # end of token &lt;end--no-weave&gt;
   71| 
   72|     token delimited-no-weave {
   73|         &lt;begin-no-weave&gt;
   74|             &lt;plain-line&gt;*
   75|         &lt;end-no-weave&gt;
   76|     } # end of token delimited-no-weave
</pre></section>
<section name="pod">
<h3 id="The_plain-line_token"><a href="#A_grammar_to_parse_a_file_into_Pod_and_Code_sections." class="u" title="go to top of document">The <code>plain-line</code> token</a></h3>
<p>The <code>plain-line</code> token is, really, any line at all... ... except for one subtlety. They it can't be one of the begin/end delimiters. We can specify that with a <a href="https://docs.raku.org/language/regexes\#Regex_Boolean_condition_check">Regex Boolean Condition Check</a>.</p></section>
<section name="pod"><pre class="pod-block-code">   77|     my token full-line-comment {
   78|         $&lt;the-code&gt;=(&lt;leading-ws&gt;)
   79|         '#'
   80|         &lt;rest-of-line&gt;
   81|     } # end of my token full-line-comment
   82| 
   83|     #TODO this regex is not robust.  It will tag lines with a # in a string,
   84|     #unless the string delimiter is immediately before the #
   85|     my regex code-comment {
   86|         $&lt;the-code&gt;=(&lt;leading-ws&gt; \N*?)  # optional code
   87|         &lt;!after &lt;opening-quote&gt;&gt;         #
   88|         '#'                              # comment marker
   89|         $&lt;the-comment&gt;=&lt;-[#]&gt;*           # the actual comment
   90|         &lt;ws-till-EOL&gt;
   91|     } # end of my regex comment
   92| 
   93|     token plain-line {
   94|         :my $*EXCEPTION = False;
   95|         [
   96|           ||  &lt;begin-pod&gt;         { $*EXCEPTION = True }
   97|           ||  &lt;end-pod&gt;           { $*EXCEPTION = True }
   98|           ||  &lt;begin-no-weave&gt;    { $*EXCEPTION = True }
   99|           ||  &lt;end-no-weave&gt;      { $*EXCEPTION = True }
  100|           ||  &lt;one-line-no-weave&gt; { $*EXCEPTION = True }
  101|           || [^^ &lt;rest-of-line&gt;]
  102|         ]
  103|         &lt;?{ !$*EXCEPTION }&gt;
  104|     } # end of token plain-line
</pre></section>
<section name="pod"><p>And that concludes the grammar for separating <code>Pod</code> from <code>Code</code>!</p></section>
<section name="pod"><pre class="pod-block-code">  105| } # end of grammar Semi::Literate
</pre></section>
<section name="pod">
<h1 id="The_Tangle_subroutine"><a href="#A_grammar_to_parse_a_file_into_Pod_and_Code_sections." class="u" title="go to top of document">The Tangle subroutine</a></h1>
<p>This subroutine will remove all the Pod6 code from a semi-literate file (<code>.sl</code>) and keep only the Raku code.</p></section>
<section name="pod"><pre class="pod-block-code">  106| #TODO multi sub to accept Str &amp; IO::PatGh
  107| sub tangle (
</pre></section>
<section name="pod"><p>The subroutine has a single parameter, which is the input filename. The filename is required. Typically, this parameter is obtained from the command line or passed from the subroutine <code>MAIN</code>.</p></section>
<section name="pod"><pre class="pod-block-code">  108|     Str $input-file!,
</pre></section>
<section name="pod"><p>The subroutine will return a <code>Str</code>, which will be a working Raku program.</p></section>
<section name="pod"><pre class="pod-block-code">  109|         --&gt; Str ) is export {
</pre></section>
<section name="pod"><p>First we will get the entire Semi-Literate <code>.sl</code> file...</p></section>
<section name="pod"><pre class="pod-block-code">  110|     my Str $source = $input-file.IO.slurp;
</pre></section>
<section name="pod">
<h2 id="Clean_the_source"><a href="#A_grammar_to_parse_a_file_into_Pod_and_Code_sections." class="u" title="go to top of document">Clean the source</a></h2>

<h3 id="Remove_unnecessary_blank_lines"><a href="#A_grammar_to_parse_a_file_into_Pod_and_Code_sections." class="u" title="go to top of document">Remove unnecessary blank lines</a></h3>
<p>Very often the <code>code</code> section of the Semi-Literate file will have blank lines that you don't want to see in the tangled working code. For example:</p><pre class="pod-block-code">                                                # &lt;== unwanted blank lines
                                                # &lt;== unwanted blank lines
    sub foo () {
        { ... }
    } # end of sub foo ()
                                                # &lt;== unwanted blank lines
                                                # &lt;== unwanted blank lines

</pre></section>
<section name="pod"><p>So we'll remove the blank lines immediately outside the beginning and end of the Pod6 sections.</p></section>
<section name="pod"><pre class="pod-block-code">  111|     my Str $cleaned-source = $source;
  112|     $cleaned-source ~~ s:g{\=end (\N*)\n+} =   &quot;\=end$0\n&quot;;
  113|     $cleaned-source ~~ s:g{\n+\=begin (&lt;hws&gt; pod) [&lt;hws&gt; \d]?} = &quot;\n\=begin$0&quot;;
</pre></section>
<section name="pod">
<h2 id="The_interesting_stuff"><a href="#A_grammar_to_parse_a_file_into_Pod_and_Code_sections." class="u" title="go to top of document">The interesting stuff</a></h2>
<p>We parse it using the <code>Semi::Literate</code> grammar and obtain a list of submatches (that's what the <code>caps</code> method does) ...</p></section>
<section name="pod"><pre class="pod-block-code">  114|     my Pair @submatches = Semi::Literate.parse($cleaned-source).caps;
</pre></section>
<section name="pod"><p>...and iterate through the submatches and keep only the <code>code</code> sections...</p></section>
<section name="pod"><pre class="pod-block-code">  115| #    note &quot;submatches.elems: {@submatches.elems}&quot;;
  116|     my Str $raku-code = @submatches.map( {
  117| #        note .key;
  118|         when .key eq 'woven-code'|'non-woven-code' {
  119|             .value;
  120|         }
</pre></section>
<section name="pod">
<h3 id="Replace_Pod6_sections_with_blank_lines"><a href="#A_grammar_to_parse_a_file_into_Pod_and_Code_sections." class="u" title="go to top of document">Replace Pod6 sections with blank lines</a></h3>
</section>
<section name="pod"><pre class="pod-block-code">  121|         when .key eq 'pod' {
  122|             my $num-blank-lines =
  123|                 .value.hash&lt;blank-line-comment&gt;&lt;num-blank-lines&gt;;
  124|             &quot;\n&quot; x $num-blank-lines with $num-blank-lines;
  125|         }
  126| 
</pre></section>
<section name="pod"><p>... and we will join all the code sections together...</p></section>
<section name="pod"><pre class="pod-block-code">  127|     } # end of my Str $raku-code = @submatches.map(
  128|     ).join;
</pre></section>
<section name="pod">
<h3 id="Remove_the_no-weave_delimiters"><a href="#A_grammar_to_parse_a_file_into_Pod_and_Code_sections." class="u" title="go to top of document">Remove the <em>no-weave</em> delimiters</a></h3>
</section>
<section name="pod"><pre class="pod-block-code">  129|     $raku-code ~~ s:g{ ^^ &lt;hws&gt; '#' &lt;hws&gt; 'begin-no-weave'     &lt;rest-of-line&gt; }
  130|         = '';
  131|     $raku-code ~~ s:g{ ^^ &lt;hws&gt; '#' &lt;hws&gt; 'no-weave-this-line' &lt;rest-of-line&gt; }
  132|         = &quot;$0\n&quot;;
  133|     $raku-code ~~ s:g{ ^^ &lt;hws&gt; '#' &lt;hws&gt; 'end-no-weave'       &lt;rest-of-line&gt; }
  134|         = '';
</pre></section>
<section name="pod">
<h3 id="remove_blank_lines_at_the_end"><a href="#A_grammar_to_parse_a_file_into_Pod_and_Code_sections." class="u" title="go to top of document">remove blank lines at the end</a></h3>
</section>
<section name="pod"><pre class="pod-block-code">  135|     $raku-code ~~ s{\n  &lt;blank-line&gt;* $ } = '';
</pre></section>
<section name="pod"><p>And that's the end of the <code>tangle</code> subroutine!</p></section>
<section name="pod"><pre class="pod-block-code">  136|     return $raku-code;
  137| } # end of sub tangle (
</pre></section>
<section name="pod">
<h1 id="The_Weave_subroutine"><a href="#A_grammar_to_parse_a_file_into_Pod_and_Code_sections." class="u" title="go to top of document">The Weave subroutine</a></h1>
<p>The <code>Weave</code> subroutine will <em>weave</em> the <code>.sl</code> file into a readable Markdown, HTML, or other format. It is a little more complicated than <code>sub tangle</code> because it has to include the <code>code</code> sections.</p></section>
<section name="pod"><pre class="pod-block-code">  138| sub weave (
</pre></section>
<section name="pod">
<h2 id="The_parameters_of_Weave"><a href="#A_grammar_to_parse_a_file_into_Pod_and_Code_sections." class="u" title="go to top of document">The parameters of Weave</a></h2>
<p><code>sub weave</code> will have several parameters.</p>
<h3 id="$input-file"><a href="#A_grammar_to_parse_a_file_into_Pod_and_Code_sections." class="u" title="go to top of document"><code>$input-file</code></a></h3>
<p>The input filename is required. Typically, this parameter is obtained from the command line through a wrapper subroutine <code>MAIN</code>.</p></section>
<section name="pod"><pre class="pod-block-code">  139|     Str $input-file!;
</pre></section>
<section name="pod">
<h3 id="$format"><a href="#A_grammar_to_parse_a_file_into_Pod_and_Code_sections." class="u" title="go to top of document"><code>$format</code></a></h3>
<p>The output of the weave can (currently) be Markdown, Text, or HTML. It defaults to Markdown. The variable is case-insensitive, so 'markdown' also works.</p></section>
<section name="pod"><pre class="pod-block-code">  140|     Str :f(:$format) is copy = 'markdown';
  141|         #= The output format for the woven file.
</pre></section>
<section name="pod">
<h3 id="$line-numbers"><a href="#A_grammar_to_parse_a_file_into_Pod_and_Code_sections." class="u" title="go to top of document"><code>$line-numbers</code></a></h3>
<p>It can be useful to print line numbers in the code listing. It currently defaults to True.</p></section>
<section name="pod"><pre class="pod-block-code">  142|     Bool :l(:$line-numbers)  = True;
  143|         #= Should line numbers be added to the embeded code?
</pre></section>
<section name="pod"><p><code>sub weave</code> returns a Str.</p></section>
<section name="pod"><pre class="pod-block-code">  144|         --&gt; Str ) is export {
  145| 
  146|     my UInt $line-number = 1;
</pre></section>
<section name="pod"><p>First we will get the entire <code>.sl</code> file...</p></section>
<section name="pod"><pre class="pod-block-code">  147|     my Str $source = $input-file.IO.slurp;
</pre></section>
<section name="pod">
<h3 id="Remove_blank_lines_at_the_begining_and_end_of_the_code"><a href="#A_grammar_to_parse_a_file_into_Pod_and_Code_sections." class="u" title="go to top of document">Remove blank lines at the begining and end of the code</a></h3>
<p><strong>EXPLAIN THIS!</strong></p></section>
<section name="pod"><pre class="pod-block-code">  148|     my Str $cleaned-source = $source;
  149|     $cleaned-source ~~ s:g{\=end (\N*)\n+} =   &quot;\=end$0\n&quot;;
  150|     $cleaned-source ~~ s:g{\n+\=begin (&lt;hws&gt; pod) [&lt;hws&gt; \d]?} = &quot;\n\=begin$0&quot;;
</pre></section>
<section name="pod">
<h2 id="Interesting_stuff"><a href="#A_grammar_to_parse_a_file_into_Pod_and_Code_sections." class="u" title="go to top of document">Interesting stuff</a></h2>
<p>...Next, we parse it using the <code>Semi::Literate</code> grammar and obtain a list of submatches (that's what the <code>caps</code> method does) ...</p></section>
<section name="pod"><pre class="pod-block-code">  151|     my Pair @submatches = Semi::Literate.parse($cleaned-source).caps;
</pre></section>
<section name="pod"><p>...And now begins the interesting part. We iterate through the submatches and insert the <code>code</code> sections into the Pod6...</p></section>
<section name="pod"><p>This function checks if the line of code is a full line comment. If so, return False, so nothing will be printed for this line.</p><p>If it's a line of code with a comment at the end, remove the comment from the line and return True</p><p>Otherwise return True</p></section>
<section name="pod"><pre class="pod-block-code">  152|     sub remove-comments (Str $line is rw) {
  153|         #TODO Add a parameter to sub weave()
  154| #        return !{my $remove-comments = False};
  155| 
  156|         return True;
  157|         # don't print full line comments
  158|         return False if $line ~~ /&lt;leading-ws&gt; '#'/;
  159| 
  160|         # remove comments that are at the end of a line.
  161|         # The code will almost always end with a ';' or a '}'.
  162|         $line = $0
  163|             if $line ~~ / ^^ (&lt;optional-chars&gt; &lt;[;}]&gt; ) &lt;hws&gt; '#'/;
  164| 
  165|         return True;
  166|     } # end of sub remove-comments {Pair $p is rw}
  167| 
  168|     # The code below will occur wherever non-woven-code appeared.
  169|     # We'll need to remove it from the woven Pod6.  Otherwise, it
  170|     # creates an unseemly blank line.
  171|     my Str $unnecessary-pod6 = qq:to/EOQ/;
  172|     \=end code
  173|     \=end pod
  174|     \=begin pod
  175|     \=begin code :lang&lt;raku&gt;
  176|     EOQ
  177| 
  178| #    note &quot;weave submatches.elems: {@submatches.elems}&quot;;
  179| #    note &quot;submatches keys: {@submatchesÂ».keys}&quot;;
  180|     my $fmt = ($line-numbers ?? &quot;%3s| &quot; !! '') ~ &quot;%s\n&quot;;
  181| 
  182|     my Str $weave = @submatches.map( {
  183|         when .key eq 'pod' {
  184|             .value
  185|         } # end of when .key
  186| 
  187|         #TODO refactor that line out of this code
  188|         when .key eq 'woven-code' { qq:to/EOCB/; }
  189|             \=begin pod
  190|             \=begin code :lang&lt;raku&gt;
  191|              {
  192|                 .value
  193|                 .lines
  194|                 .map(
  195|                             $line-numbers
  196|                                 ?? {&quot;%4s| %s\n&quot;.sprintf($line-number++, $_) }
  197|                                 !! {     &quot;%s\n&quot;.sprintf(                $_) }
  198|                 )
  199|                 .chomp # get rid of the last \n
  200|              }
  201|             \=end code
  202|             \=end pod
  203|             EOCB
  204| 
  205|         when .key eq 'non-woven-code' {
  206|             ''; # don't add any text to the Pod6
  207|         } # end of when .key eq 'non-woven-code'
  208| 
  209|     } # end of my Str $weave = @submatches.map(
  210|     ).join
  211|     .subst($unnecessary-pod6, :g);
  212| 
  213| 
  214| &quot;deleteme.rakudoc&quot;.IO.spurt: $weave;
</pre></section>
<section name="pod">
<h3 id="remove_blank_lines_at_the_end"><a href="#A_grammar_to_parse_a_file_into_Pod_and_Code_sections." class="u" title="go to top of document">remove blank lines at the end</a></h3>
</section>
<section name="pod"><pre class="pod-block-code">  215|     $weave ~~ s{\n  &lt;blank-line&gt;* $ } = '';
</pre></section>
<section name="pod"><p>And that's the end of the <code>tangle</code> subroutine!</p></section>
<section name="pod"><pre class="pod-block-code">  216|     return $weave
  217| } # end of sub weave (
</pre></section>
<section name="pod">
<h1 id="NAME"><a href="#A_grammar_to_parse_a_file_into_Pod_and_Code_sections." class="u" title="go to top of document">NAME</a></h1>
<p><code>Semi::Literate</code> - A semi-literate way to weave and tangle Raku/Pod6 source code.</p>
<h1 id="VERSION"><a href="#A_grammar_to_parse_a_file_into_Pod_and_Code_sections." class="u" title="go to top of document">VERSION</a></h1>
<p>This documentation refers to <code>Semi-Literate</code> version 0.0.1</p>
<h1 id="SYNOPSIS"><a href="#A_grammar_to_parse_a_file_into_Pod_and_Code_sections." class="u" title="go to top of document">SYNOPSIS</a></h1>
<pre class="pod-block-code">use Semi::Literate;
# Brief but working code example(s) here showing the most common usage(s)

# This section will be as far as many users bother reading
# so make it as educational and exemplary as possible.

</pre>
<h1 id="DESCRIPTION"><a href="#A_grammar_to_parse_a_file_into_Pod_and_Code_sections." class="u" title="go to top of document">DESCRIPTION</a></h1>
<p><code>Semi::Literate</code> is based on Daniel Sockwell's Pod::Literate module</p><p>A full description of the module and its features. May include numerous subsections (i.e. =head2, =head2, etc.)</p>
<h1 id="BUGS_AND_LIMITATIONS"><a href="#A_grammar_to_parse_a_file_into_Pod_and_Code_sections." class="u" title="go to top of document">BUGS AND LIMITATIONS</a></h1>
<p>There are no known bugs in this module. Patches are welcome.</p>
<h1 id="AUTHOR"><a href="#A_grammar_to_parse_a_file_into_Pod_and_Code_sections." class="u" title="go to top of document">AUTHOR</a></h1>
<p>Shimon Bollinger (deoac.bollinger@gmail.com)</p>
<h1 id="LICENSE_AND_COPYRIGHT"><a href="#A_grammar_to_parse_a_file_into_Pod_and_Code_sections." class="u" title="go to top of document">LICENSE AND COPYRIGHT</a></h1>
<p>Â© 2023 Shimon Bollinger. All rights reserved.</p><p>This module is free software; you can redistribute it and/or modify it under the same terms as Raku itself. See <a href="https://opensource.org/licenses/Artistic-2.0">The Artistic License 2.0</a>.</p><p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</p></section>		</div>
</div><footer><div>Rendered from <span class="path"></span></div><div>at <span class="time">2023-09-11T17:15:10Z</span></div></footer>
	</body>
</html>

