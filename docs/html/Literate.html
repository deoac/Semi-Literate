<!doctype html>
<html lang="en">
<head>
<title>A grammar to parse a file into Pod and Code sections.</title>
<meta charset="UTF-8" />

<link href="/asset_files/images/favicon.ico" rel="icon" type="image/x-icon"/>
<link rel="stylesheet" type="text/css" href="asset_files/css/rakudoc-extra.css" />
<link rel="stylesheet" type="text/css" href="asset_files/css/font-awesome.min.css" />
<link rel="stylesheet" type="text/css" href="asset_files/css/rakudoc-styling.css" />

</head>
	<body class="pod">
<header>
<img id="Camelia_bug" src="/asset_files/images/Camelia.svg"><h1 class="title">A grammar to parse a file into Pod and Code sections.</h1></header><div class="pod-content"><nav><div id="_TOC"><table>
<caption>Table of Contents</caption>
<tr class="toc-level-1"><td class="toc-text"><a href="#INTRODUCTION">INTRODUCTION</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#Convenient_tokens">Convenient tokens</a></td></tr>
 <tr class="toc-level-1"><td class="toc-text"><a href="#The_Grammar">The Grammar</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#The_Pod6_delimiters">The Pod6 delimiters</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#The_begin_token">The begin token</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#The_end_token">The end token</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#The_Pod_token">The Pod token</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#The_Code_token">The Code token</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#Woven_sections">Woven sections</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#Non-woven_sections">Non-woven sections</a></td></tr>
 <tr class="toc-level-4"><td class="toc-text"><a href="#One_line_of_code">One line of code</a></td></tr>
 <tr class="toc-level-4"><td class="toc-text"><a href="#Delimited_blocks_of_code">Delimited blocks of code</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#The_plain-line_token">The plain-line token</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#Disallowing_the_delimiters_in_a_plain-line.">Disallowing the delimiters in a plain-line.</a></td></tr>
 <tr class="toc-level-1"><td class="toc-text"><a href="#The_Tangle_subroutine">The Tangle subroutine</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#Clean_the_source">Clean the source</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#Remove_the_no-weave_delimiters">Remove the no-weave delimiters</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#Remove_unnecessary_blank_lines">Remove unnecessary blank lines</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#The_interesting_stuff">The interesting stuff</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#Replace_Pod6_sections_with_blank_lines">Replace Pod6 sections with blank lines</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#remove_blank_lines_at_the_end">remove blank lines at the end</a></td></tr>
 <tr class="toc-level-1"><td class="toc-text"><a href="#The_Weave_subroutine">The Weave subroutine</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#The_parameters_of_Weave">The parameters of Weave</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#$input-file">$input-file</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#$format">$format</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#$line-numbers">$line-numbers</a></td></tr>
 <tr class="toc-level-2"><td class="toc-text"><a href="#Interesting_stuff_...Next,_we_parse_it_using_the_Semi::Literate_grammar_and_obtain_a_list_of_submatches_(that's_what_the_caps_method_does)_...">Interesting stuff ...Next, we parse it using the Semi::Literate grammar and obtain a list of submatches (that's what the caps method does) ...</a></td></tr>
 <tr class="toc-level-3"><td class="toc-text"><a href="#remove_blank_lines_at_the_end">remove blank lines at the end</a></td></tr>
 <tr class="toc-level-1"><td class="toc-text"><a href="#NAME">NAME</a></td></tr>
 <tr class="toc-level-1"><td class="toc-text"><a href="#VERSION">VERSION</a></td></tr>
 <tr class="toc-level-1"><td class="toc-text"><a href="#SYNOPSIS">SYNOPSIS</a></td></tr>
 <tr class="toc-level-1"><td class="toc-text"><a href="#DESCRIPTION">DESCRIPTION</a></td></tr>
 <tr class="toc-level-1"><td class="toc-text"><a href="#BUGS_AND_LIMITATIONS">BUGS AND LIMITATIONS</a></td></tr>
 <tr class="toc-level-1"><td class="toc-text"><a href="#AUTHOR">AUTHOR</a></td></tr>
 <tr class="toc-level-1"><td class="toc-text"><a href="#LICENSE_AND_COPYRIGHT">LICENSE AND COPYRIGHT</a></td></tr>
</table></div>
</nav><div id=""></div><div class="pod-body">
<section name="___top"><pre class="pod-block-code">    1| #! /usr/bin/env raku
    2| 
    3| # Get the Pod vs. Code structure of a Raku/Pod6 file.
    4| # © 2023 Shimon Bollinger. All rights reserved.
    5| # Last modified: Sat 02 Sep 2023 11:19:41 PM EDT
    6| # Version 0.0.1
    7| 
    8| # no-weave
    9| # always use the latest version of Raku
   10| use v6.*;
   11| use PrettyDump;
   12| use Data::Dump::Tree;
   13| # end-no-weave
   14| 
</pre>
<h1 id="INTRODUCTION"><a href="#A_grammar_to_parse_a_file_into_Pod_and_Code_sections." class="u" title="go to top of document">INTRODUCTION</a></h1>
<p>I want to create a semi-literate Raku source file with the extension <code>.sl</code>. Then, I will <em>weave</em> it to generate a readable file in formats like Markdown, PDF, HTML, and more. Additionally, I will <em>tangle</em> it to create source code without any Pod6.</p><p>To do this, I need to divide the file into <code>Pod</code> and <code>Code</code> sections by parsing it. For this purpose, I will create a dedicated Grammar.</p>
<h2 id="Convenient_tokens"><a href="#A_grammar_to_parse_a_file_into_Pod_and_Code_sections." class="u" title="go to top of document">Convenient tokens</a></h2>
<p>Let's create two tokens for convenience.</p><pre class="pod-block-code">   15| 
   16| #    We need to declare them with C&lt;my&gt; because we
   17| #    need to use them in a subroutine later. #TODO explain why.
   18| 
   19|     my token rest-of-line {    \N* [\n | $]  }
   20|     my token ws-till-EOL  {    \h* [\n | $]  }
   21|     my token blank-line   { ^^ &lt;ws-till-EOL&gt; }
   22| 
</pre>
<h1 id="The_Grammar"><a href="#A_grammar_to_parse_a_file_into_Pod_and_Code_sections." class="u" title="go to top of document">The Grammar</a></h1>
<p>Our file will exclusively consist of <code>Pod</code> or <code>Code</code> sections, and nothing else. The <code>TOP</code> token clearly indicates this.</p><pre class="pod-block-code">   23| 
   24| #use Grammar::Tracer;
   25| grammar Semi::Literate is export {
   26|     token TOP {   [ &lt;pod&gt; | &lt;code&gt; ]* }
   27| 
   28| 
</pre>
<h2 id="The_Pod6_delimiters"><a href="#A_grammar_to_parse_a_file_into_Pod_and_Code_sections." class="u" title="go to top of document">The Pod6 delimiters</a></h2>
<p>According to the <a href="https://docs.raku.org/language/pod">documentation</a>,</p><dl>
<dt>Every Pod6 document has to begin with =begin pod 1 and end with =end pod.</dt><dd></dd>
</dl><p>So let's define those tokens.</p>
<h3 id="The_begin_token"><a href="#A_grammar_to_parse_a_file_into_Pod_and_Code_sections." class="u" title="go to top of document">The <code>begin</code> token</a></h3>
<pre class="pod-block-code">   29| 
   30|     my token begin {
   31|         ^^ \h* \= begin &lt;.ws&gt; pod
   32| 
</pre><p>Most programming applications do not focus on the structure of the executable file, which is not meant to be easily read by humans.</p><p>However, we can provide the option for users to specify the number of empty lines that should replace a <code>pod</code> block. To do this, simply add a number at the end of the <code>=begin</code> directive. For example, <code>=begin pod 2</code>. <sup><a name="fnret1" href="#fn1">[1]</a></sup>
</p><pre class="pod-block-code">   33| 
   34|         [ \h* $&lt;num-blank-lines&gt;=(\d+) ]?  # an optional number to specify the
   35|                                          # number of blank lines to replace the
   36|                                          # C&lt;Pod&gt; blocks when tangling.
</pre><p>The remainder of the <code>begin</code> directive can only be whitespace.</p><pre class="pod-block-code">   37| 
   38|         &lt;ws-till-EOL&gt;
   39|     } # end of my token begin
   40| 
</pre>
<h3 id="The_end_token"><a href="#A_grammar_to_parse_a_file_into_Pod_and_Code_sections." class="u" title="go to top of document">The <code>end</code> token</a></h3>
<p>The <code>end</code> token is much simpler.</p><pre class="pod-block-code">   41| 
   42|     my token end { ^^ \h* \= end &lt;.ws&gt; pod &lt;ws-till-EOL&gt; }
   43| 
</pre>
<h2 id="The_Pod_token"><a href="#A_grammar_to_parse_a_file_into_Pod_and_Code_sections." class="u" title="go to top of document">The <code>Pod</code> token</a></h2>
<p>Within the delimiters, all lines are considered documentation. We will refer to these lines as <code>plain-lines</code>. Additionally, it is possible to have nested <code>Pod</code> sections. This allows for a hierarchical organization of documentation, allowing for more structured and detailed explanations.</p><p>It is also permissible for the block to be empty. Therefore, we will use the 'zero-or-more' quantifier on the lines of documentation, allowing for the possibility of having no lines in the block.</p><pre class="pod-block-code">   44| 
   45|     token pod {
   46|         &lt;begin&gt;
   47|             [&lt;pod&gt; | &lt;plain-line&gt;]*
   48|         &lt;end&gt;
   49|     } # end of token pod
   50| 
</pre>
<h2 id="The_Code_token"><a href="#A_grammar_to_parse_a_file_into_Pod_and_Code_sections." class="u" title="go to top of document">The <code>Code</code> token</a></h2>
<p>The <code>Code</code> sections are similarly easily defined. There are two types of <code>Code</code> sections, depending on whether they will appear in the woven code. See <a href="#no-weave">no-weave</a> for why some code would not be included in the woven code.</p><pre class="pod-block-code">   51| 
   52|     token code {
   53|         | &lt;woven&gt;
   54|         | &lt;non-woven&gt;
   55|     } # end of token code
</pre>
<h3 id="Woven_sections"><a href="#A_grammar_to_parse_a_file_into_Pod_and_Code_sections." class="u" title="go to top of document">Woven sections</a></h3>
<p>These sections are trivially defined. They are just one or more <code>plain-line</code>s.</p><pre class="pod-block-code">   56| 
   57|     token woven { &lt;plain-line&gt;+ }
</pre>
<h3 id="Non-woven_sections"><a href="#A_grammar_to_parse_a_file_into_Pod_and_Code_sections." class="u" title="go to top of document">Non-woven sections</a></h3>
<p>Sometimes there will be code you do not want woven into the document, such as boilerplate code like <code>use v6.d;</code>. You have two options to mark such code. By individual lines or by delimited blocks of code.</p><pre class="pod-block-code">   58| 
   59|     token non-woven {
   60|         | &lt;one-line-no-weave&gt;+
   61|         | &lt;delimited-no-weave&gt;+
   62|     } # end of token non-woven
</pre>
<h4 id="One_line_of_code"><a href="#A_grammar_to_parse_a_file_into_Pod_and_Code_sections." class="u" title="go to top of document">One line of code</a></h4>
<p>Simply append <code>#no-weave</code> at the end of the line!</p><pre class="pod-block-code">   63| 
   64|     token one-line-no-weave {
   65|         ^^ \N*
   66|         '#' &lt;.ws&gt; 'no-weave'
   67|         &lt;.ws&gt; &lt;rest-of-line&gt;
   68|     } # end of token one-line-no-weave
   69| 
</pre>
<h4 id="Delimited_blocks_of_code"><a href="#A_grammar_to_parse_a_file_into_Pod_and_Code_sections." class="u" title="go to top of document">Delimited blocks of code</a></h4>
<p>Simply add comments <code>#no-weave</code> and <code>#end-no-weave</code> before and after the code you want ignored in the formatted document.</p><pre class="pod-block-code">   70|     token delimited-no-weave {
   71|         &lt;begin-no-weave&gt;
   72|             &lt;plain-line&gt;*?
   73|         &lt;end-no-weave&gt;
   74|     } # end of token delimited-no-weave
   75| 
   76|     token begin-no-weave {
   77|         ^^ \h*                      # optional leading whitespace
   78|         '#' &lt;.ws&gt; 'no-weave'        # the delimiter itself (#no-weave)
   79|         &lt;.ws&gt; &lt;rest-of-line&gt;        # optional trailing whitespace
   80|     } # end of token &lt;begin-no-weave&gt;
   81| 
   82|     token end-no-weave {
   83|         ^^ \h*                      # optional leading whitespace
   84|         '#' &lt;.ws&gt; 'end-no-weave'    # the delimiter itself (#end-no-weave)
   85|         &lt;.ws&gt; &lt;rest-of-line&gt;        # optional trailing whitespace
   86|     } # end of token &lt;end--no-weave&gt;
   87| 
</pre>
<h3 id="The_plain-line_token"><a href="#A_grammar_to_parse_a_file_into_Pod_and_Code_sections." class="u" title="go to top of document">The <code>plain-line</code> token</a></h3>
<p>The <code>plain-line</code> token is, really, any line at all...</p><pre class="pod-block-code">   88| 
   89|     token plain-line {
   90|        $&lt;plain-line&gt; = [^^ &lt;rest-of-line&gt;]
   91| 
</pre>
<h3 id="Disallowing_the_delimiters_in_a_plain-line."><a href="#A_grammar_to_parse_a_file_into_Pod_and_Code_sections." class="u" title="go to top of document">Disallowing the delimiters in a <code>plain-line</code>.</a></h3>
<p>... except for one subtlety. They it can't be one of the begin/end delimiters. We can specify that with a <a href="https://docs.raku.org/language/regexes\#Regex_Boolean_condition_check">Regex Boolean Condition Check</a>.</p><pre class="pod-block-code">   92| 
   93|         &lt;?{ &amp;not-a-delimiter($&lt;plain-line&gt;.Str) }&gt;
   94|     } # end of token plain-line
   95| 
</pre><p>This function simply checks whether the <code>plain-line</code> match object matches either the <code>begin</code> or <code>end</code> token.</p><p>Incidentally, this function is why we had to declare those tokens with the <code>my</code> keyword. This function wouldn't work otherwise.</p><pre class="pod-block-code">   96| 
   97|     sub not-a-delimiter (Str $line --&gt; Bool) {
   98|         return not $line ~~ /&lt;begin&gt; | &lt;end&gt;/;
   99|     } # end of sub not-a-delimiter (Match $line --&gt; Bool)
  100| 
</pre><p>And that concludes the grammar for separating <code>Pod</code> from <code>Code</code>!</p><pre class="pod-block-code">  101| 
  102| } # end of grammar Semi::Literate
  103| 
</pre>
<h1 id="The_Tangle_subroutine"><a href="#A_grammar_to_parse_a_file_into_Pod_and_Code_sections." class="u" title="go to top of document">The Tangle subroutine</a></h1>
<p>This subroutine will remove all the Pod6 code from a semi-literate file (<code>.sl</code>) and keep only the Raku code.</p><pre class="pod-block-code">  104| 
  105| #TODO multi sub to accept Str &amp; IO::PatGh
  106| sub tangle (
  107| 
</pre><p>The subroutine has a single parameter, which is the input filename. The filename is required. Typically, this parameter is obtained from the command line or passed from the subroutine <code>MAIN</code>.</p><pre class="pod-block-code">  108|     Str $input-file!,
</pre><p>The subroutine will return a <code>Str</code>, which will be a working Raku program.</p><pre class="pod-block-code">  109|         --&gt; Str ) is export {
</pre><p>First we will get the entire Semi-Literate <code>.sl</code> file...</p><pre class="pod-block-code">  110| 
  111|     my Str $source = $input-file.IO.slurp;
  112| 
</pre>
<h2 id="Clean_the_source"><a href="#A_grammar_to_parse_a_file_into_Pod_and_Code_sections." class="u" title="go to top of document">Clean the source</a></h2>

<h3 id="Remove_the_no-weave_delimiters"><a href="#A_grammar_to_parse_a_file_into_Pod_and_Code_sections." class="u" title="go to top of document">Remove the <em>no-weave</em> delimiters</a></h3>
<pre class="pod-block-code">  113| 
  114|     $source ~~ s:g{ ^^ \h* '#' &lt;.ws&gt;     'no-weave' &lt;rest-of-line&gt; } = '';
  115|     $source ~~ s:g{ ^^ \h* '#' &lt;.ws&gt; 'end-no-weave' &lt;rest-of-line&gt; } = '';
  116| 
</pre>
<h3 id="Remove_unnecessary_blank_lines"><a href="#A_grammar_to_parse_a_file_into_Pod_and_Code_sections." class="u" title="go to top of document">Remove unnecessary blank lines</a></h3>
<p>Very often the <code>code</code> section of the Semi-Literate file will have blank lines that you don't want to see in the tangled working code. For example:</p><pre class="pod-block-code">                                                # &lt;== unwanted blank lines
                                                # &lt;== unwanted blank lines
    sub foo () {
        { ... }
    } # end of sub foo ()
                                                # &lt;== unwanted blank lines
                                                # &lt;== unwanted blank lines

</pre><pre class="pod-block-code">  117| 
</pre><p>So we'll remove the blank lines at the beginning and end of the Pod6 sections.</p><pre class="pod-block-code">  118| 
  119|     $source ~~ s:g/\=end (\N*)\n+/\=end$0\n/;
  120|     $source ~~ s:g/\n+\=begin    /\n\=begin/;
  121| 
</pre>
<h2 id="The_interesting_stuff"><a href="#A_grammar_to_parse_a_file_into_Pod_and_Code_sections." class="u" title="go to top of document">The interesting stuff</a></h2>
<p>We parse it using the <code>Semi::Literate</code> grammar and obtain a list of submatches (that's what the <code>caps</code> method does) ...</p><pre class="pod-block-code">  122| 
  123|     my Pair @submatches = Semi::Literate.parse($source).caps;
  124| 
</pre><p>...and iterate through the submatches and keep only the <code>code</code> sections...</p><pre class="pod-block-code">  125| 
  126|     my Str $raku-code = @submatches.map( {
  127|         when .key eq 'code' {
  128|             .value;
  129|         }
  130| 
</pre>
<h3 id="Replace_Pod6_sections_with_blank_lines"><a href="#A_grammar_to_parse_a_file_into_Pod_and_Code_sections." class="u" title="go to top of document">Replace Pod6 sections with blank lines</a></h3>
<p>#TODO rewrite Most programming applications do not focus on the structure of the executable file, which is not meant to be easily read by humans.</p><p>However, we can provide the option for users to specify the number of empty lines that should replace a <code>pod</code> block. To do this, simply add a number at the end of the <code>=begin</code> directive. For example, <code>=begin pod 2</code> .</p><pre class="pod-block-code">  131| 
  132| 
  133|         when .key eq 'pod' {
  134|             my $num-blank-lines = .value.hash&lt;begin&gt;&lt;num-blank-lines&gt;;
  135|             &quot;\n&quot; x $num-blank-lines with $num-blank-lines;
  136|         }
  137| 
  138|         #no-weave
  139|         default { die 'Should never get here' }
  140|         #end-no-weave
</pre><p>... and we will join all the code sections together...</p><pre class="pod-block-code">  141| 
  142|     } # end of my Str $raku-code = @submatches.map(
  143|     ).join;
  144| 
</pre>
<h3 id="remove_blank_lines_at_the_end"><a href="#A_grammar_to_parse_a_file_into_Pod_and_Code_sections." class="u" title="go to top of document">remove blank lines at the end</a></h3>
<pre class="pod-block-code">  145| 
  146|     $raku-code ~~ s{\n  &lt;blank-line&gt;* $ } = '';
  147| 
</pre><p>And that's the end of the <code>tangle</code> subroutine!</p><pre class="pod-block-code">  148|     return $raku-code;
  149| } # end of sub tangle (
  150| 
</pre>
<h1 id="The_Weave_subroutine"><a href="#A_grammar_to_parse_a_file_into_Pod_and_Code_sections." class="u" title="go to top of document">The Weave subroutine</a></h1>
<p>The <code>Weave</code> subroutine will <em>weave</em> the <code>.sl</code> file into a readable Markdown, HTML, or other format. It is a little more complicated than <code>sub tangle</code> because it has to include the <code>code</code> sections.</p><pre class="pod-block-code">  151| 
  152| sub weave (
  153| 
</pre>
<h2 id="The_parameters_of_Weave"><a href="#A_grammar_to_parse_a_file_into_Pod_and_Code_sections." class="u" title="go to top of document">The parameters of Weave</a></h2>
<p><code>sub weave</code> will have several parameters.</p>
<h3 id="$input-file"><a href="#A_grammar_to_parse_a_file_into_Pod_and_Code_sections." class="u" title="go to top of document"><code>$input-file</code></a></h3>
<p>The input filename is required. Typically, this parameter is obtained from the command line through a wrapper subroutine <code>MAIN</code>.</p><pre class="pod-block-code">  154| 
  155|     Str $input-file!;
</pre>
<h3 id="$format"><a href="#A_grammar_to_parse_a_file_into_Pod_and_Code_sections." class="u" title="go to top of document"><code>$format</code></a></h3>
<p>The output of the weave can (currently) be Markdown, Text, or HTML. It defaults to Markdown. The variable is case-insensitive, so 'markdown' also works.</p><pre class="pod-block-code">  156| 
  157|     Str :f(:$format) is copy = 'markdown';
  158|         #= The output format for the woven file.
  159| 
</pre>
<h3 id="$line-numbers"><a href="#A_grammar_to_parse_a_file_into_Pod_and_Code_sections." class="u" title="go to top of document"><code>$line-numbers</code></a></h3>
<p>It can be useful to print line numbers in the code listing. It currently defaults to True.</p><pre class="pod-block-code">  160| 
  161|     Bool :l(:$line-numbers)  = True;
  162|         #= Should line numbers be added to the embeded code?
  163| 
  164| 
</pre><p><code>sub weave</code> returns a Str.</p><pre class="pod-block-code">  165| 
  166|         --&gt; Str ) is export {
</pre><p>#TODO</p><pre class="pod-block-code">  167| 
  168|     my UInt $line-number = 1;
  169| 
</pre><p>First we will get the entire <code>.sl</code> file...</p><pre class="pod-block-code">  170| 
  171|     my Str $source = $input-file.IO.slurp;
  172| 
  173|     my Str $cleaned-source;
  174| 
  175| $cleaned-source = $source;
  176| #=begin pod 1
  177| #
  178| #=head3 Remove full comment lines followed by blank lines
  179| #
  180| #=end pod
  181| #
  182| #    # delete full comment lines
  183| #    $source ~~ s:g{ ^^ \h* '#' \N* \n+} = '';
  184| #
  185| #    # remove Raku comments, unless the '#' is escaped with
  186| #    # a backslash or is in a quote. (It doesn't catch all quote
  187| #    # constructs...(that's a TODO))
  188| #    # And leave the newline.
  189| #
  190| #=begin pod 1
  191| #
  192| #=head3 Remove EOL comments
  193| #
  194| #=end pod
  195| #
  196| #    for $source.split(&quot;\n&quot;) -&gt; $line {
  197| #        my $m = $line ~~ m{
  198| #                ^^
  199| #               $&lt;stuff-before-the-comment&gt; = ( \N*? )
  200| #
  201| #                #TODO make this more robust - allow other delimiters, take into
  202| #                #account the Q language, heredocs, nested strings...
  203| #                &lt;!after         # make sure the '#' isn't in a string
  204| #                    ( [
  205| #                        | \\
  206| #                        | \&quot; &lt;-[\&quot;]&gt;*
  207| #                        | \' &lt;-[\']&gt;*
  208| #                        | \｢ &lt;-[\｣]&gt;*
  209| #                    ] )
  210| #                &gt;
  211| #                &quot;#&quot;
  212| #
  213| #
  214| #                # We need to keep these delimiters.
  215| #                # See the section above &quot;Remove code marked as 'no-weave'&quot;.
  216| #                &lt;!before
  217| #                      [
  218| #                        | 'no-weave'
  219| #                        | 'end-no-weave'
  220| #                      ]
  221| #                &gt;
  222| #                \N*
  223| #                $$ };
  224| #
  225| #        $cleaned-source ~= $m ?? $&lt;stuff-before-the-comment&gt; !! $line;
  226| #        $cleaned-source ~= &quot;\n&quot;;
  227| #    } # end of for $source.split(&quot;\n&quot;) -&gt; $line
  228| #
  229| #=begin pod 1
  230| #=head3 Remove blank lines at the begining and end of the code
  231| #
  232| #B&lt;EXPLAIN THIS!&gt;
  233| #
  234| #=end pod
  235| #
  236| #    $cleaned-source ~~ s:g{\=end (\N*)\n+} =   &quot;\=end$0\n&quot;;
  237| #    $cleaned-source ~~ s:g{\n+\=begin (&lt;.ws&gt; pod) [&lt;.ws&gt; \d]?} = &quot;\n\=begin$0&quot;;
  238| #
</pre>
<h2 id="Interesting_stuff_...Next,_we_parse_it_using_the_Semi::Literate_grammar_and_obtain_a_list_of_submatches_(that's_what_the_caps_method_does)_..."><a href="#A_grammar_to_parse_a_file_into_Pod_and_Code_sections." class="u" title="go to top of document">Interesting stuff ...Next, we parse it using the <code>Semi::Literate</code> grammar and obtain a list of submatches (that's what the <code>caps</code> method does) ...</a></h2>
<pre class="pod-block-code">  239| 
  240|     my Pair @submatches = Semi::Literate.parse($cleaned-source).caps;
  241| 
</pre><p>...And now begins the interesting part. We iterate through the submatches and insert the <code>code</code> sections into the Pod6...</p><pre class="pod-block-code">  242| 
  243| 
  244|     my Str $weave = @submatches.map( {
  245|         when .key eq 'pod' {
  246|             .value
  247|         } # end of when .key
</pre><p>#TODO</p><pre class="pod-block-code">  248| 
  249|         when .key eq 'code' { qq:to/EOCB/; }
  250|             \=begin  pod
  251|             \=begin  code :lang&lt;raku&gt;
  252|              { my $fmt = ($line-numbers ?? &quot;%3s| &quot; !! '') ~ &quot;%s\n&quot;;
  253|                 .value
  254|                 .lines
  255|                 .map($line-numbers
  256|                         ?? {&quot;%4s| %s\n&quot;.sprintf($line-number++, $_) }
  257|                         !! {     &quot;%s\n&quot;.sprintf(                $_) }
  258|                     )
  259|                 .chomp;
  260|              }
  261|             \=end  code
  262|             \=end  pod
  263|             EOCB
  264| 
  265|         when .key eq 'non-woven' {
  266|             ; # do nothing
  267|         } # end of when .key eq 'non-woven'
  268| 
  269|         # no-weave
  270|         default { die 'Should never get here.' }
  271|         # end-no-weave
  272|     } # end of my $weave = Semi::Literate.parse($source).caps.map
  273|     ).join;
  274| 
</pre><p>remove useless Pod directives</p><pre class="pod-block-code">  275| 
  276|     $weave ~~ s:g{ \h* \=end   &lt;.ws&gt; pod  &lt;rest-of-line&gt;
  277|                    \h* \=begin &lt;.ws&gt; pod &lt;rest-of-line&gt; } = '';
  278| 
</pre>
<h3 id="remove_blank_lines_at_the_end"><a href="#A_grammar_to_parse_a_file_into_Pod_and_Code_sections." class="u" title="go to top of document">remove blank lines at the end</a></h3>
<pre class="pod-block-code">  279| 
  280|     $weave ~~ s{\n  &lt;blank-line&gt;* $ } = '';
  281| 
</pre><p>And that's the end of the <code>tangle</code> subroutine!</p><pre class="pod-block-code">  282| 
  283|     return $weave
  284| } # end of sub weave (
  285| 
</pre>
<h1 id="NAME"><a href="#A_grammar_to_parse_a_file_into_Pod_and_Code_sections." class="u" title="go to top of document">NAME</a></h1>
<p><code>Semi::Literate</code> - A semi-literate way to weave and tangle Raku/Pod6 source code.</p>
<h1 id="VERSION"><a href="#A_grammar_to_parse_a_file_into_Pod_and_Code_sections." class="u" title="go to top of document">VERSION</a></h1>
<p>This documentation refers to <code>Semi-Literate</code> version 0.0.1</p>
<h1 id="SYNOPSIS"><a href="#A_grammar_to_parse_a_file_into_Pod_and_Code_sections." class="u" title="go to top of document">SYNOPSIS</a></h1>
<pre class="pod-block-code">use Semi::Literate;
# Brief but working code example(s) here showing the most common usage(s)

# This section will be as far as many users bother reading
# so make it as educational and exemplary as possible.

</pre>
<h1 id="DESCRIPTION"><a href="#A_grammar_to_parse_a_file_into_Pod_and_Code_sections." class="u" title="go to top of document">DESCRIPTION</a></h1>
<p><code>Semi::Literate</code> is based on Daniel Sockwell's Pod::Literate module</p><p>A full description of the module and its features. May include numerous subsections (i.e. =head2, =head2, etc.)</p>
<h1 id="BUGS_AND_LIMITATIONS"><a href="#A_grammar_to_parse_a_file_into_Pod_and_Code_sections." class="u" title="go to top of document">BUGS AND LIMITATIONS</a></h1>
<p>There are no known bugs in this module. Patches are welcome.</p>
<h1 id="AUTHOR"><a href="#A_grammar_to_parse_a_file_into_Pod_and_Code_sections." class="u" title="go to top of document">AUTHOR</a></h1>
<p>Shimon Bollinger (deoac.bollinger@gmail.com)</p>
<h1 id="LICENSE_AND_COPYRIGHT"><a href="#A_grammar_to_parse_a_file_into_Pod_and_Code_sections." class="u" title="go to top of document">LICENSE AND COPYRIGHT</a></h1>
<p>© 2023 Shimon Bollinger. All rights reserved.</p><p>This module is free software; you can redistribute it and/or modify it under the same terms as Raku itself. See <a href="https://opensource.org/licenses/Artistic-2.0">The Artistic License 2.0</a>.</p><p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</p><pre class="pod-block-code">  286| 
  287| # no-weave
  288| my %*SUB-MAIN-OPTS =
  289|   :named-anywhere,             # allow named variables at any location
  290|   :bundling,                   # allow bundling of named arguments
  291| #  :coerce-allomorphs-to(Str),  # coerce allomorphic arguments to given type
  292|   :allow-no,                   # allow --no-foo as alternative to --/foo
  293|   :numeric-suffix-as-value,    # allow -j2 as alternative to --j=2
  294| ;
  295| 
  296| #| Run with option '--pod' to see all of the Pod6 objects
  297| multi MAIN(Bool :$pod!) is hidden-from-USAGE {
  298|     for $=pod -&gt; $pod-item {
  299|         for $pod-item.contents -&gt; $pod-block {
  300|             $pod-block.raku.say;
  301|         }
  302|     }
  303| } # end of multi MAIN (:$pod)
  304| 
  305| #| Run with option '--doc' to generate a document from the Pod6
  306| #| It will be rendered in Text format
  307| #| unless specified with the --format option.  e.g.
  308| #|       --doc --format=HTML
  309| multi MAIN(Bool :$doc!, Str :$format = 'Text') is hidden-from-USAGE {
  310|     run $*EXECUTABLE, &quot;--doc=$format&quot;, $*PROGRAM;
  311| } # end of multi MAIN(Bool :$man!)
  312| 
  313| my $semi-literate-file = '/Users/jimbollinger/Documents/Development/raku/Projects/Semi-Literate/source/Literate.sl';
  314| multi MAIN(Bool :$testt!) {
  315|     say tangle($semi-literate-file);
  316| } # end of multi MAIN(Bool :$test!)
  317| 
  318| multi MAIN(Bool :$testw!) {
  319|     say weave($semi-literate-file);
  320| } # end of multi MAIN(Bool :$test!)
  321| 
  322| #end-no-weave
</pre></section>		</div>
<div id="_Footnotes" class="footnotes">
<ul><li id="fn1"><span class="footnote-number">1</span>This is non-standard Pod6 and will not compile until woven!<a class="footnote" href="#fnret1"> « Back »</a></li>

</ul>
</div>
</div><footer><div>Rendered from <span class="path"></span></div><div>at <span class="time">2023-09-03T03:46:31Z</span></div></footer>
	</body>
</html>

