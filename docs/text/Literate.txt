        1| #! /usr/bin/env raku
        2| 
        3| # Get the Pod vs. Code structure of a Raku/Pod6 file.
        4| # © 2023 Shimon Bollinger. All rights reserved.
        5| # Last modified: Mon 11 Sep 2023 01:11:01 PM EDT
        6| # Version 0.0.1
        7| 


TITLE
A grammar to parse a file into Pod and Code sections.

INTRODUCTION

I want to create a semi-literate Raku source file with the extension .sl.
Then, I will weave it to generate a readable file in formats like Markdown,
PDF, HTML, and more. Additionally, I will tangle it to create source code
without any Pod6.

  Convenient tokens

Let's create some tokens for convenience.

        8|     #TODO put these in a Role
        9|     my token hws            {    <!ww>\h*       } # Horizontal White Space
       10|     my token leading-ws     { ^^ <hws>          } # Whitespace at start of line
       11|     my token optional-chars {    \N*?           }


       12|     my token opening-quote { <
       13|                               :Ps +
       14|                               :Pi +
       15|                               [\' \" \\]
       16|                              >
       17|     } # end of my token opening-quote


To do this, I need to divide the file into Pod and Code sections by parsing
it. For this purpose, I will create a dedicated Grammar.

The Grammar

       18| #use Grammar::Tracer;
       19| grammar Semi::Literate is export {


Our file will exclusively consist of Pod or Code sections, and nothing
else. The Code sections are of two types, a) code that is woven into the
documentation, and b) code that is not woven into the documentation. The
TOP token clearly indicates this.

       20|     token TOP {
       21|         [
       22|           || <pod>
       23|           || <non-woven-code>
       24|           || <woven-code>
       25|         ]*
       26|     } # end of token TOP


  The Pod6 delimiters

According to the documentation,

Every Pod6 document has to begin with =begin pod and end with =end pod.


So let's define those tokens.

    The begin-pod token

       27|     token begin-pod {
       28|         ^^ <hws> '=' begin <hws> pod <ws-till-EOL>
       29|     } # end of token begin-pod


    The end-pod token

The end-pod token is much simpler.

       30|     token end-pod { ^^ <hws> '=' end <hws> pod <ws-till-EOL> }


    Replacing Pod6 sections with blank lines

Most programming applications do not focus on the structure of the
executable file, which is not meant to be easily read by humans. Our tangle
would replace all the Pod6 blocks with a single \n. That can clump code
together that is easier read if there were one or more blank lines.

However, we can provide the option for users to specify the number of empty
lines that should replace a pod block. To do this, simply add a Pod6
comment immediately after the =begin pod statement. The comment can say
anything you like, but must end with a digit specifying the number of blank
lines with which to replace the Pod6 section.

       31|     token blank-line-comment {
       32|         ^^ <hws>
       33|         '=' comment
       34|         \N*?
       35|         $<num-blank-lines> = (\d+)?
       36|         <ws-till-EOL>
       37|     } # end of token blank-line-comment


  The Pod token

Within the delimiters, all lines are considered documentation. We will
refer to these lines as plain-lines. Additionally, it is possible to have
nested Pod sections. This allows for a hierarchical organization of
documentation, allowing for more structured and detailed explanations.

It is also permissible for the block to be empty. Therefore, we will use
the 'zero-or-more' quantifier on the lines of documentation, allowing for
the possibility of having no lines in the block.

       38|     token pod {
       39|         <begin-pod>
       40|         <blank-line-comment>?
       41|             [<pod> | <plain-line>]*
       42|         <end-pod>
       43|     } # end of token pod


  The Code tokens

The Code sections are similarly easily defined. There are two types of Code
sections, depending on whether they will appear in the woven code. See
below for why some code would not be included in the woven code.

    Woven sections

These sections are trivially defined. They are just one or more
plain-lines.

       44|     token woven-code  {
       45|         [
       46|             || <plain-line>
       47|         ]+
       48|     } # end of token woven-code


    Non-woven sections

Sometimes there will be code you do not want woven into the document, such
as boilerplate code like use v6.d;. You have two options to mark such code.
By individual lines or by delimited blocks of code.

       49|     token non-woven-code {
       50|         [
       51|           || <one-line-no-weave>
       52|           || <delimited-no-weave>
       53|         ]+
       54|     } # end of token non-woven


    One line of code

Simply append # begin-no-weave at the end of the line!

       55|     token one-line-no-weave {
       56|         ^^ \N*?
       57|         '#' <hws> 'no-weave-this-line'
       58|         <ws-till-EOL>
       59|     } # end of token one-line-no-weave


    Delimited blocks of code

Simply add comments # begin-no-weave and #end-no-weave before and after the
code you want ignored in the formatted document.

       60|     token begin-no-weave {
       61|         ^^ <hws>                    # optional leading whitespace
       62|         '#' <hws> 'begin-no-weave'  # the delimiter itself (# begin-no-weave)
       63|         <ws-till-EOL>               # optional trailing whitespace or comment
       64|     } # end of token <begin-no-weave>
       65| 
       66|     token end-no-weave {
       67|         ^^ <hws>                    # optional leading whitespace
       68|         '#' <hws> 'end-no-weave'    # the delimiter itself (#end-no-weave)
       69|         <ws-till-EOL>               # optional trailing whitespace or comment
       70|     } # end of token <end--no-weave>
       71| 
       72|     token delimited-no-weave {
       73|         <begin-no-weave>
       74|             <plain-line>*
       75|         <end-no-weave>
       76|     } # end of token delimited-no-weave


    The plain-line token

The plain-line token is, really, any line at all... ... except for one
subtlety. They it can't be one of the begin/end delimiters. We can specify
that with a Regex Boolean Condition Check.

       77|     my token full-line-comment {
       78|         $<the-code>=(<leading-ws>)
       79|         '#'
       80|         <rest-of-line>
       81|     } # end of my token full-line-comment
       82| 
       83|     #TODO this regex is not robust.  It will tag lines with a # in a string,
       84|     #unless the string delimiter is immediately before the #
       85|     my regex code-comment {
       86|         $<the-code>=(<leading-ws> \N*?)  # optional code
       87|         <!after <opening-quote>>         #
       88|         '#'                              # comment marker
       89|         $<the-comment>=<-[#]>*           # the actual comment
       90|         <ws-till-EOL>
       91|     } # end of my regex comment
       92| 
       93|     token plain-line {
       94|         :my $*EXCEPTION = False;
       95|         [
       96|           ||  <begin-pod>         { $*EXCEPTION = True }
       97|           ||  <end-pod>           { $*EXCEPTION = True }
       98|           ||  <begin-no-weave>    { $*EXCEPTION = True }
       99|           ||  <end-no-weave>      { $*EXCEPTION = True }
      100|           ||  <one-line-no-weave> { $*EXCEPTION = True }
      101|           || [^^ <rest-of-line>]
      102|         ]
      103|         <?{ !$*EXCEPTION }>
      104|     } # end of token plain-line


And that concludes the grammar for separating Pod from Code!

      105| } # end of grammar Semi::Literate


The Tangle subroutine

This subroutine will remove all the Pod6 code from a semi-literate file
(.sl) and keep only the Raku code.

      106| #TODO multi sub to accept Str & IO::PatGh
      107| sub tangle (


The subroutine has a single parameter, which is the input filename. The
filename is required. Typically, this parameter is obtained from the
command line or passed from the subroutine MAIN.

      108|     Str $input-file!,


The subroutine will return a Str, which will be a working Raku program.

      109|         --> Str ) is export {


First we will get the entire Semi-Literate .sl file...

      110|     my Str $source = $input-file.IO.slurp;


  Clean the source

    Remove unnecessary blank lines

Very often the code section of the Semi-Literate file will have blank lines
that you don't want to see in the tangled working code. For example:

                                                    # <== unwanted blank lines
                                                    # <== unwanted blank lines
        sub foo () {
            { ... }
        } # end of sub foo ()
                                                    # <== unwanted blank lines
                                                    # <== unwanted blank lines



So we'll remove the blank lines immediately outside the beginning and end
of the Pod6 sections.

      111|     my Str $cleaned-source = $source;
      112|     $cleaned-source ~~ s:g{\=end (\N*)\n+} =   "\=end$0\n";
      113|     $cleaned-source ~~ s:g{\n+\=begin (<hws> pod) [<hws> \d]?} = "\n\=begin$0";


  The interesting stuff

We parse it using the Semi::Literate grammar and obtain a list of
submatches (that's what the caps method does) ...

      114|     my Pair @submatches = Semi::Literate.parse($cleaned-source).caps;


...and iterate through the submatches and keep only the code sections...

      115| #    note "submatches.elems: {@submatches.elems}";
      116|     my Str $raku-code = @submatches.map( {
      117| #        note .key;
      118|         when .key eq 'woven-code'|'non-woven-code' {
      119|             .value;
      120|         }


    Replace Pod6 sections with blank lines

      121|         when .key eq 'pod' {
      122|             my $num-blank-lines =
      123|                 .value.hash<blank-line-comment><num-blank-lines>;
      124|             "\n" x $num-blank-lines with $num-blank-lines;
      125|         }
      126| 


... and we will join all the code sections together...

      127|     } # end of my Str $raku-code = @submatches.map(
      128|     ).join;


    Remove the no-weave delimiters

      129|     $raku-code ~~ s:g{ ^^ <hws> '#' <hws> 'begin-no-weave'     <rest-of-line> }
      130|         = '';
      131|     $raku-code ~~ s:g{ ^^ <hws> '#' <hws> 'no-weave-this-line' <rest-of-line> }
      132|         = "$0\n";
      133|     $raku-code ~~ s:g{ ^^ <hws> '#' <hws> 'end-no-weave'       <rest-of-line> }
      134|         = '';


    remove blank lines at the end

      135|     $raku-code ~~ s{\n  <blank-line>* $ } = '';


And that's the end of the tangle subroutine!

      136|     return $raku-code;
      137| } # end of sub tangle (


The Weave subroutine

The Weave subroutine will weave the .sl file into a readable Markdown,
HTML, or other format. It is a little more complicated than sub tangle
because it has to include the code sections.

      138| sub weave (


  The parameters of Weave

sub weave will have several parameters.

    $input-file

The input filename is required. Typically, this parameter is obtained from
the command line through a wrapper subroutine MAIN.

      139|     Str $input-file!;


    $format

The output of the weave can (currently) be Markdown, Text, or HTML. It
defaults to Markdown. The variable is case-insensitive, so 'markdown' also
works.

      140|     Str :f(:$format) is copy = 'markdown';
      141|         #= The output format for the woven file.


    $line-numbers

It can be useful to print line numbers in the code listing. It currently
defaults to True.

      142|     Bool :l(:$line-numbers)  = True;
      143|         #= Should line numbers be added to the embeded code?


sub weave returns a Str.

      144|         --> Str ) is export {
      145| 
      146|     my UInt $line-number = 1;


First we will get the entire .sl file...

      147|     my Str $source = $input-file.IO.slurp;


    Remove blank lines at the begining and end of the code

EXPLAIN THIS!

      148|     my Str $cleaned-source = $source;
      149|     $cleaned-source ~~ s:g{\=end (\N*)\n+} =   "\=end$0\n";
      150|     $cleaned-source ~~ s:g{\n+\=begin (<hws> pod) [<hws> \d]?} = "\n\=begin$0";


  Interesting stuff

...Next, we parse it using the Semi::Literate grammar and obtain a list of
submatches (that's what the caps method does) ...

      151|     my Pair @submatches = Semi::Literate.parse($cleaned-source).caps;


...And now begins the interesting part. We iterate through the submatches
and insert the code sections into the Pod6...

This function checks if the line of code is a full line comment. If so,
return False, so nothing will be printed for this line.

If it's a line of code with a comment at the end, remove the comment from
the line and return True

Otherwise return True

      152|     sub remove-comments (Str $line is rw) {
      153|         #TODO Add a parameter to sub weave()
      154| #        return !{my $remove-comments = False};
      155| 
      156|         return True;
      157|         # don't print full line comments
      158|         return False if $line ~~ /<leading-ws> '#'/;
      159| 
      160|         # remove comments that are at the end of a line.
      161|         # The code will almost always end with a ';' or a '}'.
      162|         $line = $0
      163|             if $line ~~ / ^^ (<optional-chars> <[;}]> ) <hws> '#'/;
      164| 
      165|         return True;
      166|     } # end of sub remove-comments {Pair $p is rw}
      167| 
      168|     # The code below will occur wherever non-woven-code appeared.
      169|     # We'll need to remove it from the woven Pod6.  Otherwise, it
      170|     # creates an unseemly blank line.
      171|     my Str $unnecessary-pod6 = q:to/EOQ/;
      172|     \=end code
      173|     \=end pod
      174|     \=begin pod
      175|     \=begin code :lang<raku>
      176|     EOQ
      177| 
      178| #    note "weave submatches.elems: {@submatches.elems}";
      179| #    note "submatches keys: {@submatches».keys}";
      180|     my $fmt = ($line-numbers ?? "%3s| " !! '') ~ "%s\n";
      181| 
      182|     my Str $weave = @submatches.map( {
      183|         when .key eq 'pod' {
      184|             .value
      185|         } # end of when .key
      186| 
      187|         #TODO refactor that line out of this code
      188|         when .key eq 'woven-code' { qq:to/EOCB/; }
      189|             \=begin pod
      190|             \=begin code :lang<raku>
      191|              {
      192|                 .value
      193|                 .lines
      194|                 .map(
      195|                             $line-numbers
      196|                                 ?? {"%4s| %s\n".sprintf($line-number++, $_) }
      197|                                 !! {     "%s\n".sprintf(                $_) }
      198|                 )
      199|                 .chomp # get rid of the last \n
      200|              }
      201|             \=end code
      202|             \=end pod
      203|             EOCB
      204| 
      205|         when .key eq 'non-woven-code' {
      206|             ''; # don't add any text to the Pod6
      207|         } # end of when .key eq 'non-woven-code'
      208| 


      209|     } # end of my Str $weave = @submatches.map(
      210|     ).join
      211|     .subst($unnecessary-pod6, :g);
      212| 
      213| 
      214| "deleteme.rakudoc".IO.spurt: $weave;


    remove blank lines at the end

      215|     $weave ~~ s{\n  <blank-line>* $ } = '';


And that's the end of the tangle subroutine!

      216|     return $weave
      217| } # end of sub weave (


NAME

Semi::Literate - A semi-literate way to weave and tangle Raku/Pod6 source
code.

VERSION

This documentation refers to Semi-Literate version 0.0.1

SYNOPSIS

    use Semi::Literate;
    # Brief but working code example(s) here showing the most common usage(s)

    # This section will be as far as many users bother reading
    # so make it as educational and exemplary as possible.



DESCRIPTION

Semi::Literate is based on Daniel Sockwell's Pod::Literate module

A full description of the module and its features. May include numerous
subsections (i.e. =head2, =head2, etc.)

BUGS AND LIMITATIONS

There are no known bugs in this module. Patches are welcome.

AUTHOR

Shimon Bollinger (deoac.bollinger@gmail.com)

LICENSE AND COPYRIGHT

© 2023 Shimon Bollinger. All rights reserved.

This module is free software; you can redistribute it and/or modify it
under the same terms as Raku itself. See The Artistic License 2.0.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.
