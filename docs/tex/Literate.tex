\documentclass{scrartcl}
\usepackage{hyperref}
\usepackage{color}
\usepackage{listings}
\usepackage{fontspec}

\definecolor{keyword0}{RGB}{133,153,0}
\definecolor{keyword1}{RGB}{220,50,47}
\definecolor{keyword2}{RGB}{181,137,0}
\definecolor{keyword3}{RGB}{203,75,22}
\definecolor{string}{RGB}{108,113,196}
\definecolor{comment}{RGB}{102,123,131}
\definecolor{background}{RGB}{253,246,227}
\lstdefinelanguage{Perl6} {
    morekeywords={[0]class,role,grammar,method,given,submethod,sub},
    morekeywords={[1]when,rw,required},
    morekeywords={[2]True,False,Bool,Str,Int,Positional,IO},
    morekeywords={[3]has,my,is,unit},
    sensitive=false,
    morecomment=[l]{\#},
    morecomment=[s]{/*}{*/},
    morestring=[b]",
}

\lstset{
    basicstyle=\footnotesize,
    numbers=left,
    keepspaces=true,
    showstringspaces=false,
    showtabs=false,
    keywordstyle={[0]\color{keyword0}\textbf},
    keywordstyle={[1]\color{keyword1}\textbf},
    keywordstyle={[2]\color{keyword2}},
    keywordstyle={[3]\color{keyword3}},
    stringstyle={\color{string}\textit},
    backgroundcolor=\color{background},
    commentstyle=\color{comment}
}
\title{An implementation of Semi-Literate programming for Raku with Pod6}
\begin{document}
\maketitle
Pod::Block::Comment<2234963108160>

\title{An implementation of Semi-Literate programming for Raku with Pod6}

\section{INTRODUCTION}

Pod::Block::Comment<2234963108208>

I want to create a semi-literate Raku source file with the extension
\texttt{.sl}. Then, I will \textit{weave} it to generate a readable file in
formats like Markdown, PDF, HTML, and more. Additionally, I will
\textit{tangle} it to create source code without any Pod6.

To do this, I need to divide the file into \texttt{Pod} and \texttt{Code}
sections by parsing it. For this purpose, I will create a dedicated
Grammar.

(See \href{https://github.com/deoac/Useful-Regexes}{Useful::Regexes} for
the definitions of the named regexes used here. (\texttt{hws} == Horizontal
WhiteSpace))

\section{The Grammar}

Pod::Block::Comment<2234963108208>

\begin{lstlisting}[language=Raku]
    3| grammar Semi::Literate is export does Useful::Regexes {

\end{lstlisting}


Our file will exclusively consist of \texttt{Pod} or \texttt{Code}
sections, and nothing else. The \texttt{Code} sections are of two types, a)
code that is woven into the documentation, and b) code that is not woven
into the documentation. The \texttt{TOP} token clearly indicates this.

\begin{lstlisting}[language=Raku]
    4|     token TOP {
    5|         [
    6|           || <pod>
    7|           || <code>
    8|         ]*
    9|     } 
   10| 
   11|     token code  {
   12|         [
   13|           || <non-woven>+
   14|           || <woven>+
   15|         ]
   16|     } 

\end{lstlisting}


Pod::Block::Comment<2234963108160>

\subsection{The Pod6 delimiters}

According to the \href{https://docs.raku.org/language/pod}{documentation},

Pod::Defn<2234882284680>

So let's define those tokens.

\subsubsection{The \texttt{begin-pod} token}

\begin{lstlisting}[language=Raku]
   17|     token begin-pod {
   18|         <leading-ws>
   19|         '=' begin <hws> pod
   20|         <ws-till-EOL>
   21|     } 

\end{lstlisting}


Pod::Block::Comment<2234963108160>

\subsubsection{The \texttt{end-pod} token}

The \texttt{end-pod} token is much simpler.

\begin{lstlisting}[language=Raku]
   22|     token end-pod  {
   23|         <leading-ws>
   24|         '=' end <hws> pod
   25|         <ws-till-EOL>
   26|     } 

\end{lstlisting}


Pod::Block::Comment<2234963108160>

\subsection{Replacing Pod6 sections with blank lines}

When we \textit{tangle} the semi-literate code, all the Pod6 will be
removed. This would leave a lot of blank lines in the Raku code. So we'll
clean it up. We provide the option for users to specify the number of empty
lines that should replace a \texttt{pod} block. To do this, simply add a
Pod6 comment immediately after the \texttt{=begin pod} statement. The
comment can say anything you like, but must end with a digit specifying the
number of blank lines with which to replace the Pod6 section.

\begin{lstlisting}[language=Raku]
    =begin pod
    =comment I want this pod block replaced by only one line 1
    ...
    =end pod

\end{lstlisting}


Here's the relevant regex:

\begin{lstlisting}[language=Raku]
   27|     token blank-line-comment {
   28|         <leading-ws>
   29|         '=' comment
   30|         \N*?
   31|         $<num-blank-lines> = (\d+)?
   32|         <ws-till-EOL>
   33|     } 

\end{lstlisting}


Pod::Block::Comment<2234963108160>

\subsection{The \texttt{Pod} token}

Within the delimiters, all lines are considered documentation. We will
refer to these lines as \texttt{plain-lines}. Additionally, it is possible
to have nested \texttt{Pod} sections. This allows for a hierarchical
organization of documentation, allowing for more structured and detailed
explanations.

It is also permissible for the block to be empty. Therefore, we will use
the 'zero-or-more' quantifier on the lines of documentation, allowing for
the possibility of having no lines in the block.

\begin{lstlisting}[language=Raku]
   34|     token pod {
   35|         <.begin-pod>
   36|         <blank-line-comment>?
   37|             [<pod> | <.plain-line>]*
   38|         <.end-pod>
   39|     } 

\end{lstlisting}


Pod::Block::Comment<2234963108160>

\subsection{The \texttt{Code} tokens}

The \texttt{Code} sections are similarly easily defined. There are two
types of \texttt{Code} sections, depending on whether they will appear in
the woven code.

\subsubsection{Woven sections}

These sections are trivially defined. They are just one or more
\texttt{plain-line}s.

\begin{lstlisting}[language=Raku]
   40|     token woven  {
   41|         [
   42|             || <.plain-line>
   43|         ]+
   44|     } 

\end{lstlisting}


Pod::Block::Comment<2234963108160>

\subsubsection{Non-woven sections}

Sometimes there will be code you do not want woven into the documentation,
such as boilerplate code like \texttt{use v6.d;}. You have two options to
mark such code. By individual lines or by a delimited block of code.

\begin{lstlisting}[language=Raku]
   45|     token non-woven {
   46|         [
   47|           || <.one-line-no-weave>
   48|           || <.delimited-no-weave>
   49|         ]+
   50|     } 

\end{lstlisting}


Pod::Block::Comment<2234963108160>

Simply append \texttt{\# no-weave-this-line} at the end of the line!

\begin{lstlisting}[language=Raku]
   51|     regex one-line-no-weave {
   52|         $<the-code>=(<leading-ws> <optional-chars>)
   53|         '#' <hws> 'no-weave-this-line'
   54|         <ws-till-EOL>
   55|     } 

\end{lstlisting}


Pod::Block::Comment<2234963108160>

Simply add comments \texttt{\# begin-no-weave} and \texttt{\#end-no-weave}
before and after the code you want ignored in the formatted document.

\begin{lstlisting}[language=Raku]
   56|     token begin-no-weave {
   57|         <leading-ws>
   58|         '#' <hws> 'begin-no-weave'
   59|         <ws-till-EOL>
   60|     } 
   61| 
   62|     token end-no-weave {
   63|         <leading-ws>
   64|         '#' <hws> 'end-no-weave'
   65|         <ws-till-EOL>
   66|     } 
   67| 
   68|     token delimited-no-weave {
   69|         <.begin-no-weave>
   70|             <.plain-line>*
   71|         <.end-no-weave>
   72|     } 

\end{lstlisting}


Pod::Block::Comment<2234963108160>

\subsubsection{The \texttt{plain-line} token}

The \texttt{plain-line} token is, really, any line at all… … except for one
subtlety. They it can't be one of the begin/end delimiters. We can specify
that with a
\href{https://docs.raku.org/language/regexes\#Regex_Boolean_condition_check}{Regex
Boolean Condition Check}.

\begin{lstlisting}[language=Raku]
   73|     token plain-line {
   74|         :my $*EXCEPTION = False;
   75|         [
   76|           ||  <.begin-pod>         { $*EXCEPTION = True }
   77|           ||  <.end-pod>           { $*EXCEPTION = True }
   78|           ||  <.begin-no-weave>    { $*EXCEPTION = True }
   79|           ||  <.end-no-weave>      { $*EXCEPTION = True }
   80|           ||  <.one-line-no-weave> { $*EXCEPTION = True }
   81|           || [^^ <rest-of-line>]
   82|         ]
   83|         <?{ !$*EXCEPTION }>
   84|     } 

\end{lstlisting}


Pod::Block::Comment<2234963108160>

And that concludes the grammar for separating \texttt{Pod} from
\texttt{Code}!

\begin{lstlisting}[language=Raku]
   85| } 

\end{lstlisting}


Pod::Block::Comment<2234963108208>

\section{The Tangle subroutine}

This subroutine will remove all the Pod6 code from a semi-literate file
(\texttt{.sl}) and keep only the Raku code.

\begin{lstlisting}[language=Raku]
   86| 
   87| multi tangle (

\end{lstlisting}


The subroutine has a single parameter, which is the input filename. The
filename is required. Typically, this parameter is obtained from the
command line or passed from the subroutine \texttt{MAIN}.

\begin{lstlisting}[language=Raku]
   88|     Str $input-file!,

\end{lstlisting}


Pod::Block::Comment<2234963108160>

\subsubsection{\texttt{\$verbose} Use verbose only for debugging}

\begin{lstlisting}[language=Raku]
   89|     Bool :v(:$verbose)      = False;

\end{lstlisting}


The subroutine will return a \texttt{Str}, which will be a working Raku
program.

\begin{lstlisting}[language=Raku]
   90|         --> Str ) is export {

\end{lstlisting}


Pod::Block::Comment<2234963108160>

First we will get the entire Semi-Literate \texttt{.sl} file…

\begin{lstlisting}[language=Raku]
   91|     my Str $source = $input-file.IO.slurp;

\end{lstlisting}


Pod::Block::Comment<2234963108160>

\subsection{Clean the source}

\subsubsection{Remove unnecessary blank lines}

Very often the \texttt{code} section of the Semi-Literate file will have
blank lines that you don't want to see in the tangled working code. For
example:

\begin{lstlisting}[language=Raku]
                                                # <== unwanted blank lines
                                                # <== unwanted blank lines
    sub foo () {
        { ... }
    } # end of sub foo ()
                                                # <== unwanted blank lines
                                                # <== unwanted blank lines


\end{lstlisting}


Pod::Block::Comment<2234963108160>

So we'll remove the blank lines immediately outside the beginning and end
of the Pod6 sections.

\begin{lstlisting}[language=Raku]
   92|     my Str $cleaned-source = $source;
   93|     $cleaned-source ~~ s:g{    \=end (\N*) \n+}      =  "\=end$0\n";
   94|     $cleaned-source ~~ s:g{\n+ \=begin (<hws> pod) } = "\n\=begin$0";

\end{lstlisting}


Pod::Block::Comment<2234963108160>

\subsection{The interesting stuff}

We parse it using the \texttt{Semi::Literate} grammar and obtain a list of
submatches (that's what the \texttt{caps} method does) …

\begin{lstlisting}[language=Raku]
   95|     my Pair @submatches = Semi::Literate.parse($cleaned-source).caps;
   96| 
   97|     my Str $raku-code = @submatches.map( {

\end{lstlisting}


Pod::Block::Comment<2234963108160>

\subsubsection{Replace Pod6 sections with blank lines}

\begin{lstlisting}[language=Raku]
   98|         when .key eq 'pod' {
   99|             my $num-blank-lines =
  100|                 .value.hash<blank-line-comment><num-blank-lines>;
  101|             "\n" x $num-blank-lines with $num-blank-lines;
  102|         }

\end{lstlisting}


Pod::Block::Comment<2234963108160>

Add all the \texttt{Code} sections.

\begin{lstlisting}[language=Raku]
  103|         when .key eq 'code' {
  104|             .value;
  105|         } 
  106| 

\end{lstlisting}


Pod::Block::Comment<2234963108160>

… and we will join all the code sections together…

\begin{lstlisting}[language=Raku]
  107|     } 
  108|     ).join;

\end{lstlisting}


Pod::Block::Comment<2234963108160>

\subsubsection{Remove the \textit{no-weave} delimiters}

\begin{lstlisting}[language=Raku]
  109|     $raku-code ~~ s:g{
  110|                         | <Semi::Literate::begin-no-weave>
  111|                         | <Semi::Literate::end-no-weave>
  112|                   } = '';
  113| 
  114|     $raku-code ~~ s:g{ <Semi::Literate::one-line-no-weave> }
  115|                     = "$<Semi::Literate::one-line-no-weave><the-code>\n";

\end{lstlisting}


Pod::Block::Comment<2234963108160>

\subsubsection{remove blank lines at the end}

\begin{lstlisting}[language=Raku]
  116|     $raku-code ~~ s{\n  <blank-line>* $ } = '';

\end{lstlisting}


Pod::Block::Comment<2234963108160>

And that's the end of the \texttt{tangle} subroutine!

\begin{lstlisting}[language=Raku]
  117|     return $raku-code;
  118| } 

\end{lstlisting}


Pod::Block::Comment<2234963108208>

\section{The Weave subroutine}

The \texttt{Weave} subroutine will \textit{weave} the \texttt{.sl} file
into a readable Markdown, HTML, or other format. It is a little more
complicated than \texttt{sub tangle} because it has to include the
\texttt{code} sections.

\begin{lstlisting}[language=Raku]
  119| sub weave (

\end{lstlisting}


Pod::Block::Comment<2234963108160>

\subsection{The parameters of Weave}

\texttt{sub weave} will have several parameters.

\subsubsection{\texttt{\$input-file}}

The input filename is required. Typically, this parameter is obtained from
the command line through a wrapper subroutine \texttt{MAIN}.

\begin{lstlisting}[language=Raku]
  120|     Str $input-file!;

\end{lstlisting}


Pod::Block::Comment<2234963108160>

\subsubsection{\texttt{\$line-numbers}}

It can be useful to print line numbers in the code listing. It currently
defaults to True.

\begin{lstlisting}[language=Raku]
  121|     Bool :l(:$line-numbers) = True;

\end{lstlisting}


Pod::Block::Comment<2234963108160>

\subsubsection{\texttt{\$verbose} Use verbose only for debugging}

\begin{lstlisting}[language=Raku]
  122|     Bool :v(:$verbose)      = False;

\end{lstlisting}


\texttt{sub weave} returns a Str.

\begin{lstlisting}[language=Raku]
  123|         --> Str ) is export {
  124| 
  125|     my UInt $line-number = 1;

\end{lstlisting}


First we will get the entire \texttt{.sl} file…

\begin{lstlisting}[language=Raku]
  126|     my Str $source = $input-file.IO.slurp;

\end{lstlisting}


Pod::Block::Comment<2234963108160>

\subsubsection{Remove blank lines at the begining and end of the code}

B → EXPLAIN THIS!

\begin{lstlisting}[language=Raku]
  127|     my Str $cleaned-source = $source;
  128|     $cleaned-source ~~ s:g{    \=end (\N*) \n+}      =  "\=end$0\n";
  129|     $cleaned-source ~~ s:g{\n+ \=begin (<hws> pod) } = "\n\=begin$0";

\end{lstlisting}


Pod::Block::Comment<2234963108160>

\subsubsection{remove blank lines at the end of the code}

\begin{lstlisting}[language=Raku]
  130|     $cleaned-source ~~ s{\n  <blank-line>* $ } = '';

\end{lstlisting}


Pod::Block::Comment<2234963108160>

\subsection{Interesting stuff}

…Next, we parse it using the \texttt{Semi::Literate} grammar and obtain a
list of submatches (that's what the \texttt{caps} method does) …

\begin{lstlisting}[language=Raku]
  131|     my Pair @submatches = Semi::Literate.parse($cleaned-source).caps;

\end{lstlisting}


Pod::Block::Comment<2234963108160>

…And now begins the interesting part. We iterate through the submatches and
insert the \texttt{code} sections into the Pod6…

This function checks if the line of code is a full line comment. If so,
return False, so nothing will be printed for this line.

The function will return a \texttt{Seq}uence of (possibly) modified lines.
It needs to be a \texttt{Seq} because the return value will then be fed to
a feed operator (\texttt{==\textbackslash }>)

\begin{lstlisting}[language=Raku]
  132|     sub remove-comments (Seq $lines --> List) {
  133| 
  134|         my token full-line-comment {
  135|             $<the-code>=(<leading-ws>)
  136|             '#'
  137|             <rest-of-line>
  138|         } 
  139| 
  140|         my regex partial-line-comment {
  141|             $<the-code>=(<leading-ws> <optional-chars>)  
  142|             <!after <opening-quote>>         
  143|             '#'                              
  144|             $<the-comment>=<-[#]>*           
  145|             <ws-till-EOL>
  146|         } 
  147| 
  148|         my @retval = ();
  149|         for $lines.List -> $line {
  150|             given $line {
  151|                 when /<full-line-comment>/ {; 
  152| 
  153|                 when /<partial-line-comment>/ {
  154|                     @retval.push: $<partial-line-comment><the-code>;
  155|                 }
  156| 
  157|                 default
  158|                     { @retval.push: $line; }
  159|             } 
  160|         } 
  161| 
  162|         return @retval;
  163|     } 
  164| 
  165|     my Str $weave = @submatches.map( {
  166|         when .key eq 'pod' {
  167|             .value
  168|         } 
  169| 
  170|         when .key eq 'code' {
  171|             { qq:to/EOCB/ if .<code><woven>; }
  172|             \=begin pod
  173|             \=begin code :lang<raku>
  174|              {
  175|                 $_<code><woven>
  176|                 ==> lines()
  177|                 ==> remove-comments()
  178|                 ==> map(
  179|                         $line-numbers
  180|                             ?? {"%4s| %s\n".sprintf($line-number++, $_) }
  181|                             !! {     "%s\n".sprintf(                $_) }
  182|                 )
  183|                 ==> chomp() 
  184|              }
  185|             \=end code
  186|             \=end pod
  187|             EOCB
  188|         } 
  189| 
  190|     } 
  191|     ).join;

\end{lstlisting}


Pod::Block::Comment<2234963108160>

\subsubsection{Remove unseemly blank lines}

\begin{lstlisting}[language=Raku]
  192|     my Str $non-woven-blank-lines = qq:to/EOQ/;
  193|         \=end code
  194|         \=end pod
  195|         \=begin pod
  196|         \=begin code :lang<raku>
  197|         EOQ
  198| 
  199|     my Regex $full-comment-blank-lines = rx[
  200|         '=begin pod'              <ws-till-EOL>
  201|         '=begin code :lang<raku>' <ws-till-EOL>
  202|         [<leading-ws> \d+ | '|'?  <ws-till-EOL>]*
  203|         '=end code'               <ws-till-EOL>
  204|         '=end pod'                <ws-till-EOL>
  205|     ];
  206| 
  207|     $weave ~~ s:g{ $non-woven-blank-lines | <$full-comment-blank-lines> } = '';

\end{lstlisting}


Pod::Block::Comment<2234963108160>

And that's the end of the \texttt{weave} subroutine!

\begin{lstlisting}[language=Raku]
  208|     return $weave
  209| } 

\end{lstlisting}


Pod::Block::Comment<2234963108160>

\section{NAME}

\texttt{Semi::Literate} - A semi-literate way to weave and tangle Raku/Pod6
source code.

\section{VERSION}

This documentation refers to \texttt{Semi-Literate} version 0.0.1

\section{SYNOPSIS}

\begin{lstlisting}[language=Raku]
use Semi::Literate;
# Brief but working code example(s) here showing the most common usage(s)

# This section will be as far as many users bother reading
# so make it as educational and exemplary as possible.


\end{lstlisting}


\section{DESCRIPTION}

\subsection{Influences}

\texttt{Semi::Literate} is based on Daniel Sockwell's
\href{https://www.codesections.com/blog/weaving-raku/}{Pod::Literate}.

Also influenced by zyedidia's
<Literate|https://zyedidia.github.io/literate/> program. Especially the
idea of not weaving some portions of the code.

A full description of the module and its features. May include numerous
subsections (i.e. =head2, =head2, etc.)

\section{DEPENDENCIES}

\begin{lstlisting}[language=Perl6]
Useful::Regexes
\end{lstlisting}


\section{BUGS AND LIMITATIONS}

There are no known bugs in this module. Patches are welcome.

\section{AUTHOR}

Shimon Bollinger (deoac.bollinger@gmail.com)

\section{LICENSE AND COPYRIGHT}

© 2023 Shimon Bollinger. All rights reserved.

This module is free software; you can redistribute it and/or modify it
under the same terms as Raku itself. See
\href{https://opensource.org/licenses/Artistic-2.0}{The Artistic License
2.0}.

This program is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
FITNESS FOR A PARTICULAR PURPOSE.\end{document}
